<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Upload EPUB</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    @keyframes pulse-border {
      0% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.4); }
      70% { box-shadow: 0 0 0 15px rgba(59, 130, 246, 0); }
      100% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0); }
    }
    .dragging { animation: pulse-border 1.2s infinite; background-color: rgba(59, 130, 246, 0.05); }
  </style>
</head>
<body class="h-screen flex items-center justify-center bg-gray-100 relative">

  <div id="dropzone"
    class="relative w-[90%] h-[80%] max-w-5xl border-4 border-dashed border-gray-300 rounded-3xl flex flex-col items-center justify-center transition-all duration-300 ease-in-out cursor-pointer bg-white hover:border-blue-500 p-8">
    <p class="text-gray-500 text-center text-lg leading-relaxed">
      <strong>Drag and drop</strong> your EPUB file here<br>
      or <strong>click to upload</strong>.
    </p>
  </div>

  <input id="fileInputElement" type="file" accept=".epub" class="hidden" />

  <div id="epubInfo" class="hidden w-[90%] max-w-6xl bg-white rounded-3xl shadow-xl p-10 flex gap-10 items-start flex-col md:flex-row">
    <div id="coverContainer" class="w-full max-w-md bg-gray-200 rounded-xl flex items-center justify-center overflow-hidden shadow-lg">
      <span class="text-gray-400">No Cover</span>
    </div>
    <div class="flex flex-col justify-between flex-grow min-w-[250px]">
      <div>
        <h2 id="title" class="text-3xl font-bold mb-4">Unknown Title</h2>
        <p id="author" class="text-xl text-gray-600 mb-6">Unknown Author</p>
        <div class="flex gap-4">
          <button id="downloadButton" class="bg-green-500 text-white px-4 py-2 rounded-xl hover:bg-green-600 transition">Modify & Download EPUB</button>
          <button id="resetButton" class="bg-red-500 text-white px-4 py-2 rounded-xl hover:bg-red-600 transition">Upload New EPUB</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    let currentZip = null, coverPathInZip = null, currentFileName = 'modified';

    const dropzone = document.getElementById('dropzone');
    const fileInputElement = document.getElementById('fileInputElement');
    const epubInfo = document.getElementById('epubInfo');
    const coverContainer = document.getElementById('coverContainer');
    const titleEl = document.getElementById('title');
    const authorEl = document.getElementById('author');
    const downloadButton = document.getElementById('downloadButton');
    const resetButton = document.getElementById('resetButton');

    function getFirstTagTextContent(doc, tag, namespace = null) {
      let elements = namespace 
        ? doc.getElementsByTagNameNS(namespace, tag) 
        : doc.getElementsByTagName(tag);
      return elements.length > 0 ? elements[0].textContent : null;
    }

    dropzone.onclick = () => fileInputElement.click();
    fileInputElement.onchange = (e) => e.target.files[0] && handleFile(e.target.files[0]);
    downloadButton.onclick = async () => {
      const coverBlob = await currentZip.files[coverPathInZip].async('blob');
      const modifiedCover = await adjustCoverImageToAspectRatio(coverBlob);
      currentZip.file(coverPathInZip, modifiedCover);
      const newEpub = await currentZip.generateAsync({ type: 'blob' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(newEpub);
      a.download = `${currentFileName.replace(/\.epub$/i, '')}_coverfix.epub`;
      a.click();
    };

    resetButton.onclick = () => {
      epubInfo.classList.add('hidden');
      dropzone.classList.remove('hidden');
      fileInputElement.value = '';
      currentZip = null;
      coverPathInZip = null;
      currentFileName = 'modified';
    };

    async function handleFile(file) {
      currentFileName = file.name;
      currentZip = await JSZip.loadAsync(await file.arrayBuffer());
      const container = await currentZip.files['META-INF/container.xml'].async('text');
      const parser = new DOMParser();
      const opfPath = parser.parseFromString(container, 'application/xml').querySelector('rootfile').getAttribute('full-path');
      const opf = await currentZip.files[opfPath].async('text');
      const opfDoc = parser.parseFromString(opf, 'application/xml');

      const dcNS = 'http://purl.org/dc/elements/1.1/';
      const title = getFirstTagTextContent(opfDoc, 'title', dcNS) || 'Unknown Title';
      const creator = getFirstTagTextContent(opfDoc, 'creator', dcNS) || 'Unknown Author';
      titleEl.textContent = title;
      authorEl.textContent = `by ${creator}`;

      const coverId = opfDoc.querySelector('meta[name="cover"]')?.getAttribute('content');
      const coverItem = opfDoc.querySelector(`item[id="${coverId}"]`);
      coverPathInZip = resolvePath(opfPath, coverItem?.getAttribute('href'));
      const coverBlob = await currentZip.files[coverPathInZip].async('blob');
      const coverURL = URL.createObjectURL(coverBlob);
      coverContainer.innerHTML = `<img src="${coverURL}" class="max-w-full object-contain">`;

      dropzone.classList.add('hidden');
      epubInfo.classList.remove('hidden');
    }

    function resolvePath(base, relative) {
      return base.includes('/') ? base.split('/').slice(0, -1).concat(relative).join('/') : relative;
    }

    async function adjustCoverImageToAspectRatio(blob, targetRatio = 1.329) {
  return new Promise(resolve => {
    const img = new Image();
    img.onload = () => {
      const w = img.width;
      const h = img.height;
      const currentRatio = h / w;
      let newW = w;
      let newH = h;

      // Calculate new dimensions to match the target ratio
      if (currentRatio < targetRatio) {
        newH = Math.round(w * targetRatio);
      } else if (currentRatio > targetRatio) {
        newW = Math.round(h / targetRatio);
      }

      const padX = Math.floor((newW - w) / 2);
      const padY = Math.floor((newH - h) / 2);

      const canvas = document.createElement('canvas');
      canvas.width = newW;
      canvas.height = newH;
      const ctx = canvas.getContext('2d');

      // Step 1: Stretch edges to fill the padding (nearest neighbor effect)
      ctx.drawImage(img, 0, 0, 1, h, 0, padY, padX, h); // Left edge
      ctx.drawImage(img, w - 1, 0, 1, h, padX + w, padY, padX, h); // Right edge
      ctx.drawImage(img, 0, 0, w, 1, padX, 0, w, padY); // Top edge
      ctx.drawImage(img, 0, h - 1, w, 1, padX, padY + h, w, padY); // Bottom edge

      // Step 2: Draw corners to fill empty spaces
      ctx.drawImage(img, 0, 0, 1, 1, 0, 0, padX, padY); // Top-left
      ctx.drawImage(img, w - 1, 0, 1, 1, padX + w, 0, padX, padY); // Top-right
      ctx.drawImage(img, 0, h - 1, 1, 1, 0, padY + h, padX, padY); // Bottom-left
      ctx.drawImage(img, w - 1, h - 1, 1, 1, padX + w, padY + h, padX, padY); // Bottom-right

      // Step 3: Draw the original image centered
      ctx.drawImage(img, padX, padY);

      // Step 4: Blur padded areas without affecting the center image
      ctx.globalCompositeOperation = 'destination-over';
      ctx.filter = 'blur(10px)';

      // Blur left padding
      ctx.drawImage(canvas, 0, 0, padX, newH, 0, 0, padX, newH);
      // Blur right padding
      ctx.drawImage(canvas, newW - padX, 0, padX, newH, newW - padX, 0, padX, newH);
      // Blur top padding
      ctx.drawImage(canvas, 0, 0, newW, padY, 0, 0, newW, padY);
      // Blur bottom padding
      ctx.drawImage(canvas, 0, newH - padY, newW, padY, 0, newH - padY, newW, padY);

      ctx.filter = 'none';
      ctx.globalCompositeOperation = 'source-over';

      // Final output
      canvas.toBlob(resolve, 'image/jpeg', 0.95);
    };
    img.src = URL.createObjectURL(blob);
  });
}
  </script>
</body>
</html>
